<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Simple Roblox-Inspired Game</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #87ceeb; /* sky blue */
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    canvas {
      display: block;
      background: linear-gradient(#87ceeb 70%, #4caf50 30%);
    }
    /* Top-right shame counter */
    #shameCounter {
      position: fixed;
      top: 12px;
      right: 12px;
      z-index: 10;
      background: rgba(0,0,0,0.6);
      color: #fff;
      padding: 8px 12px;
      border-radius: 8px;
      font-weight: 700;
      letter-spacing: 0.3px;
      user-select: none;
    }
  </style>
</head>
<body>
  <div id="shameCounter">Shame Hits: <span id="hitCount">0</span></div>
  <canvas id="game"></canvas>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const groundHeight = 80;
let keys = {};
let obstacles = [];
let hitCount = 0;

const hitCountEl = document.getElementById('hitCount');

/* ---------- Simple beep via Web Audio ---------- */
let audioCtx = null;
function ensureAudioContext() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
}
function beep(durationMs = 120, freq = 660) {
  if (!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();

  osc.type = 'square';
  osc.frequency.value = freq;

  const now = audioCtx.currentTime;
  gain.gain.setValueAtTime(0.001, now);
  gain.gain.exponentialRampToValueAtTime(0.2, now + 0.01);
  gain.gain.exponentialRampToValueAtTime(0.001, now + durationMs / 1000);

  osc.connect(gain).connect(audioCtx.destination);
  osc.start(now);
  osc.stop(now + durationMs / 1000 + 0.02);
}

/* ---------- Entities ---------- */
class Player {
  constructor(img) {
    this.img = img;
    this.width = 120;
    this.height = 160;
    this.x = 100;
    this.y = canvas.height - groundHeight - this.height;
    this.vy = 0;
    this.jumpPower = -16;
    this.gravity = 0.7;
    this.grounded = true;
  }
  draw() {
    ctx.drawImage(this.img, this.x, this.y, this.width, this.height);
  }
  jump() {
    if (this.grounded) {
      this.vy = this.jumpPower;
      this.grounded = false;
    }
  }
  update() {
    if (keys['ArrowUp'] || keys[' ']) {
      this.jump();
    }
    this.vy += this.gravity;
    this.y += this.vy;
    if (this.y >= canvas.height - groundHeight - this.height) {
      this.y = canvas.height - groundHeight - this.height;
      this.vy = 0;
      this.grounded = true;
    }
    this.draw();
  }
  get rect() {
    return { x: this.x, y: this.y, w: this.width, h: this.height };
  }
}

class Obstacle {
  constructor(x, width, height) {
    this.x = x;
    this.width = width;
    this.height = height;
    this.y = canvas.height - groundHeight - this.height;
    this.color = '#d32f2f';
    this.wasColliding = false;
  }
  drawNoteIcon() {
    const pad = Math.min(this.width, this.height) * 0.15;
    const w = this.width - pad * 2;
    const h = this.height - pad * 2;
    const x = this.x + pad;
    const y = this.y + pad;

    ctx.fillStyle = '#fff';
    ctx.fillRect(x, y, w, h);

    const foldSize = Math.min(w, h) * 0.22;
    ctx.fillStyle = '#e0e0e0';
    ctx.beginPath();
    ctx.moveTo(x + w, y);
    ctx.lineTo(x + w - foldSize, y);
    ctx.lineTo(x + w, y + foldSize);
    ctx.closePath();
    ctx.fill();

    ctx.strokeStyle = '#9e9e9e';
    ctx.lineWidth = Math.max(1, Math.floor(h * 0.03));
    const lines = 3;
    for (let i = 1; i <= lines; i++) {
      const ly = y + (h * (i / (lines + 1)));
      ctx.beginPath();
      ctx.moveTo(x + h * 0.12, ly);
      ctx.lineTo(x + w - h * 0.12, ly);
      ctx.stroke();
    }
  }
  draw() {
    ctx.fillStyle = this.color;
    ctx.fillRect(this.x, this.y, this.width, this.height);
    this.drawNoteIcon();
  }
  update(speed) {
    this.x -= speed;
    if (this.x + this.width < 0) {
      this.x = canvas.width + 500 + Math.random() * 700;
      this.width = 35 + Math.random() * 25;
      this.height = 24 + Math.random() * 36;
      this.y = canvas.height - groundHeight - this.height;
      this.wasColliding = false;
    }
    this.draw();
  }
  get rect() {
    return { x: this.x, y: this.y, w: this.width, h: this.height };
  }
}

/* ---------- Sprite ---------- */
const playerImg = new Image();
playerImg.src = './seth.png.png'; // use your uploaded sprite image

let player;
playerImg.onload = () => {
  player = new Player(playerImg);
  startGame();
};

/* ---------- Obstacles ---------- */
function initObstacles() {
  obstacles.length = 0;
  const count = 4;
  for (let i = 0; i < count; i++) {
    let width = 35 + Math.random() * 25;
    let height = 24 + Math.random() * 36;
    const gap = 520 + Math.random() * 320;
    obstacles.push(new Obstacle(canvas.width + i * gap, width, height));
  }
}

/* ---------- Utility ---------- */
function drawGround() {
  ctx.fillStyle = "#4caf50";
  ctx.fillRect(0, canvas.height - groundHeight, canvas.width, groundHeight);
  ctx.fillStyle = "#333";
  ctx.fillRect(0, canvas.height - groundHeight, canvas.width, 5);
}

function rectsOverlap(a, b) {
  return a.x < b.x + b.w &&
         a.x + a.w > b.x &&
         a.y < b.y + b.h &&
         a.y + a.h > b.y;
}

/* ---------- Game Loop ---------- */
const SCROLL_SPEED = 8;

function startGame() {
  initObstacles();
  animate();
}

function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawGround();

  obstacles.forEach(ob => ob.update(SCROLL_SPEED));
  player.update();

  const pRect = player.rect;
  for (const ob of obstacles) {
    const colliding = rectsOverlap(pRect, ob.rect);
    if (colliding && !ob.wasColliding) {
      hitCount++;
      hitCountEl.textContent = String(hitCount);
      beep();
    }
    ob.wasColliding = colliding;
  }

  requestAnimationFrame(animate);
}

/* ---------- Input & Resize ---------- */
function primeAudio() {
  if (!audioCtx) {
    ensureAudioContext();
    if (audioCtx.state === 'suspended') audioCtx.resume();
  }
}

function handleJumpInput() {
  primeAudio();
  player && player.jump();
}

window.addEventListener('keydown', e => {
  keys[e.key] = true;
  if (e.key === ' ' || e.key === 'ArrowUp') {
    handleJumpInput();
  }
});
window.addEventListener('keyup', e => { keys[e.key] = false; });

window.addEventListener('pointerdown', () => {
  handleJumpInput();
}, { passive: true });

window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  if (player) {
    player.y = canvas.height - groundHeight - player.height;
  }
  obstacles.forEach(ob => {
    ob.y = canvas.height - groundHeight - ob.height;
  });
});
</script>
</body>
</html>
