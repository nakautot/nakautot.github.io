<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Simple Roblox-Inspired Game</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #87ceeb; /* sky blue */
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    canvas {
      display: block;
      background: linear-gradient(#87ceeb 70%, #4caf50 30%);
    }
    /* Top-right shame counter */
    #shameCounter {
      position: fixed;
      top: 12px;
      right: 12px;
      z-index: 10;
      background: rgba(0,0,0,0.6);
      color: #fff;
      padding: 8px 12px;
      border-radius: 8px;
      font-weight: 700;
      letter-spacing: 0.3px;
      user-select: none;
    }
  </style>
</head>
<body>
  <div id="shameCounter">Shame Hits: <span id="hitCount">0</span></div>
  <canvas id="game"></canvas>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const groundHeight = 80;
let keys = {};
let obstacles = [];
let hitCount = 0;

const hitCountEl = document.getElementById('hitCount');

/* ---------- Simple beep via Web Audio ---------- */
let audioCtx = null;
function ensureAudioContext() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
}
function beep(durationMs = 120, freq = 660) {
  if (!audioCtx) return; // will initialize on first key press
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();

  osc.type = 'square';
  osc.frequency.value = freq;

  const now = audioCtx.currentTime;
  gain.gain.setValueAtTime(0.001, now);
  gain.gain.exponentialRampToValueAtTime(0.2, now + 0.01);
  gain.gain.exponentialRampToValueAtTime(0.001, now + durationMs / 1000);

  osc.connect(gain).connect(audioCtx.destination);
  osc.start(now);
  osc.stop(now + durationMs / 1000 + 0.02);
}

/* ---------- Entities ---------- */
class Player {
  constructor(img) {
    this.img = img;
    this.width = 120;
    this.height = 160;
    this.x = 100;
    this.y = canvas.height - groundHeight - this.height;
    this.vy = 0;
    this.jumpPower = -15;
    this.gravity = 0.7;
    this.grounded = true;
  }
  draw() {
    ctx.drawImage(this.img, this.x, this.y, this.width, this.height);
  }
  update() {
    if (keys['ArrowUp'] || keys[' ']) {
      if (this.grounded) {
        this.vy = this.jumpPower;
        this.grounded = false;
      }
    }
    this.vy += this.gravity;
    this.y += this.vy;
    if (this.y >= canvas.height - groundHeight - this.height) {
      this.y = canvas.height - groundHeight - this.height;
      this.vy = 0;
      this.grounded = true;
    }
    this.draw();
  }
  get rect() {
    return { x: this.x, y: this.y, w: this.width, h: this.height };
  }
}

class Obstacle {
  constructor(x, width, height) {
    this.x = x;
    this.width = width;
    this.height = height;
    this.y = canvas.height - groundHeight - this.height;
    this.color = '#d32f2f';
    this.wasColliding = false; // to detect new collisions
  }
  draw() {
    ctx.fillStyle = this.color;
    ctx.fillRect(this.x, this.y, this.width, this.height);
  }
  update(speed) {
    this.x -= speed;
    if (this.x + this.width < 0) {
      // respawn ahead with some random spacing
      this.x = canvas.width + 200 + Math.random() * 400;
      this.width = 40 + Math.random() * 30;
      this.height = 40 + Math.random() * 60;
      this.y = canvas.height - groundHeight - this.height;
      this.wasColliding = false; // reset collision state
    }
    this.draw();
  }
  get rect() {
    return { x: this.x, y: this.y, w: this.width, h: this.height };
  }
}

/* ---------- Sprite ---------- */
const playerImg = new Image();
playerImg.src = './file_00000000af9461f7aa7f7b89c39b24c3.png'; // put this file alongside index.html

let player;
playerImg.onload = () => {
  player = new Player(playerImg);
  startGame();
};

/* ---------- Obstacles ---------- */
function initObstacles() {
  obstacles.length = 0;
  for (let i = 0; i < 5; i++) {
    let width = 40 + Math.random() * 30;
    let height = 40 + Math.random() * 60;
    obstacles.push(new Obstacle(canvas.width + i * 300, width, height));
  }
}

/* ---------- Utility ---------- */
function drawGround() {
  ctx.fillStyle = "#4caf50";
  ctx.fillRect(0, canvas.height - groundHeight, canvas.width, groundHeight);
  ctx.fillStyle = "#333";
  ctx.fillRect(0, canvas.height - groundHeight, canvas.width, 5);
}

function rectsOverlap(a, b) {
  return a.x < b.x + b.w &&
         a.x + a.w > b.x &&
         a.y < b.y + b.h &&
         a.y + a.h > b.y;
}

/* ---------- Game Loop ---------- */
function startGame() {
  initObstacles();
  animate();
}

function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawGround();

  // Move/draw obstacles
  obstacles.forEach(ob => ob.update(5));

  // Update/draw player
  player.update();

  // Collision detection + hit handling
  const pRect = player.rect;
  for (const ob of obstacles) {
    const colliding = rectsOverlap(pRect, ob.rect);
    if (colliding && !ob.wasColliding) {
      // New collision event with this obstacle
      hitCount++;
      hitCountEl.textContent = String(hitCount);
      beep(); // play sound
    }
    ob.wasColliding = colliding;
  }

  requestAnimationFrame(animate);
}

/* ---------- Input & Resize ---------- */
window.addEventListener('keydown', e => {
  keys[e.key] = true;
  // Ensure audio can play after a user gesture
  if (!audioCtx) {
    ensureAudioContext();
    // Some browsers require an explicit resume
    if (audioCtx.state === 'suspended') {
      audioCtx.resume();
    }
  }
});
window.addEventListener('keyup', e => { keys[e.key] = false; });

window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  if (player) {
    player.y = canvas.height - groundHeight - player.height;
  }
  // Re-seat obstacles on new ground height
  obstacles.forEach(ob => {
    ob.y = canvas.height - groundHeight - ob.height;
  });
});
</script>
</body>
</html>
