<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Simple Roblox-Inspired Game</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #87ceeb; /* sky blue */
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    canvas {
      display: block;
      background: linear-gradient(#87ceeb 70%, #4caf50 30%);
    }
    /* Top-right shame counter */
    #shameCounter {
      position: fixed;
      top: 12px;
      right: 12px;
      z-index: 10;
      background: rgba(0,0,0,0.6);
      color: #fff;
      padding: 8px 12px;
      border-radius: 8px;
      font-weight: 700;
      letter-spacing: 0.3px;
      user-select: none;
    }
  </style>
</head>
<body>
  <div id="shameCounter">Shame Hits: <span id="hitCount">0</span></div>
  <canvas id="game"></canvas>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const groundHeight = 80;
let keys = {};
let obstacles = [];
let hitCount = 0;

const hitCountEl = document.getElementById('hitCount');

/* ---------- Web Audio with iPhone unlock ---------- */
let audioCtx = null;
let audioUnlocked = false;

function ensureAudioContext() {
  if (!audioCtx) {
    const Ctx = window.AudioContext || window.webkitAudioContext;
    audioCtx = new Ctx({ latencyHint: 'interactive' });
  }
}

function oneTimeAudioUnlock() {
  if (audioUnlocked) return;
  ensureAudioContext();

  // Resume then play a tiny blip to unlock on iOS
  audioCtx.resume().then(() => {
    try {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.0001, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.02, audioCtx.currentTime + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.05);

      osc.type = 'sine';
      osc.frequency.value = 880;
      osc.connect(gain).connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.06);
      audioUnlocked = true;
      removeUnlockListeners();
    } catch (e) {
      // Ignore; will try again on next gesture
    }
  }).catch(() => {});
}

function addUnlockListeners() {
  window.addEventListener('pointerdown', oneTimeAudioUnlock, { passive: true });
  window.addEventListener('touchstart', oneTimeAudioUnlock, { passive: true });
  window.addEventListener('keydown', oneTimeAudioUnlock);
}
function removeUnlockListeners() {
  window.removeEventListener('pointerdown', oneTimeAudioUnlock);
  window.removeEventListener('touchstart', oneTimeAudioUnlock);
  window.removeEventListener('keydown', oneTimeAudioUnlock);
}
addUnlockListeners();

async function beep(durationMs = 120, freq = 660) {
  if (!audioCtx) return;
  try { if (audioCtx.state !== 'running') await audioCtx.resume(); } catch {}
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();

  osc.type = 'square';
  osc.frequency.value = freq;

  const now = audioCtx.currentTime;
  gain.gain.setValueAtTime(0.0001, now);
  gain.gain.exponentialRampToValueAtTime(0.2, now + 0.01);
  gain.gain.exponentialRampToValueAtTime(0.0001, now + durationMs / 1000);

  osc.connect(gain).connect(audioCtx.destination);
  osc.start(now);
  osc.stop(now + durationMs / 1000 + 0.02);
}

/* ---------- Entities ---------- */
class Player {
  constructor(img) {
    this.img = img;
    this.width = 120;
    this.height = 160;
    this.x = 100;
    this.y = canvas.height - groundHeight - this.height;
    this.vy = 0;
    this.jumpPower = -16;
    this.gravity = 0.7;
    this.grounded = true;
  }
  draw() {
    ctx.drawImage(this.img, this.x, this.y, this.width, this.height);
  }
  jump() {
    if (this.grounded) {
      this.vy = this.jumpPower;
      this.grounded = false;
    }
  }
  update() {
    if (keys['ArrowUp'] || keys[' ']) {
      this.jump();
    }
    this.vy += this.gravity;
    this.y += this.vy;
    if (this.y >= canvas.height - groundHeight - this.height) {
      this.y = canvas.height - groundHeight - this.height;
      this.vy = 0;
      this.grounded = true;
    }
    this.draw();
  }
  get rect() {
    return { x: this.x, y: this.y, w: this.width, h: this.height };
  }
}

class Obstacle {
  constructor(x, width, height) {
    this.x = x;
    this.width = width;
    this.height = height;
    this.y = canvas.height - groundHeight - this.height;
    this.color = '#d32f2f';
    this.wasColliding = false; // to detect new collisions
  }
  drawNoteIcon() {
    // Draw a simple "notes" icon (page with lines) centered in the obstacle
    const pad = Math.min(this.width, this.height) * 0.15;
    const w = this.width - pad * 2;
    const h = this.height - pad * 2;
    const x = this.x + pad;
    const y = this.y + pad;

    // Page background
    ctx.fillStyle = '#fff';
    ctx.fillRect(x, y, w, h);

    // Folded corner
    const foldSize = Math.min(w, h) * 0.22;
    ctx.fillStyle = '#e0e0e0';
    ctx.beginPath();
    ctx.moveTo(x + w, y);
    ctx.lineTo(x + w - foldSize, y);
    ctx.lineTo(x + w, y + foldSize);
    ctx.closePath();
    ctx.fill();

    // Lines on the note
    ctx.strokeStyle = '#9e9e9e';
    ctx.lineWidth = Math.max(1, Math.floor(h * 0.03));
    const lines = 3;
    for (let i = 1; i <= lines; i++) {
      const ly = y + (h * (i / (lines + 1)));
      ctx.beginPath();
      ctx.moveTo(x + h * 0.12, ly);
      ctx.lineTo(x + w - h * 0.12, ly);
      ctx.stroke();
    }
  }
  draw() {
    // Red block
    ctx.fillStyle = this.color;
    ctx.fillRect(this.x, this.y, this.width, this.height);
    // Notes icon
    this.drawNoteIcon();
  }
  update(speed) {
    this.x -= speed;
    if (this.x + this.width < 0) {
      // respawn farther ahead with more generous spacing and shorter blocks
      this.x = canvas.width + 500 + Math.random() * 700; // wider gaps
      this.width = 35 + Math.random() * 25; // narrower
      this.height = 24 + Math.random() * 36; // shorter
      this.y = canvas.height - groundHeight - this.height;
      this.wasColliding = false; // reset collision state
    }
    this.draw();
  }
  get rect() {
    return { x: this.x, y: this.y, w: this.width, h: this.height };
  }
}

/* ---------- Sprite ---------- */
const playerImg = new Image();
playerImg.src = './file_00000000af9461f7aa7f7b89c39b24c3.png'; // put this file alongside index.html

let player;
playerImg.onload = () => {
  player = new Player(playerImg);
  startGame();
};

/* ---------- Obstacles ---------- */
function initObstacles() {
  obstacles.length = 0;
  const count = 4; // slightly fewer obstacles
  for (let i = 0; i < count; i++) {
    // Start them far apart
    let width = 35 + Math.random() * 25;
    let height = 24 + Math.random() * 36;
    const gap = 520 + Math.random() * 320; // generous starting gaps
    obstacles.push(new Obstacle(canvas.width + i * gap, width, height));
  }
}

/* ---------- Utility ---------- */
function drawGround() {
  ctx.fillStyle = "#4caf50";
  ctx.fillRect(0, canvas.height - groundHeight, canvas.width, groundHeight);
  ctx.fillStyle = "#333";
  ctx.fillRect(0, canvas.height - groundHeight, canvas.width, 5);
}

function rectsOverlap(a, b) {
  return a.x < b.x + b.w &&
         a.x + a.w > b.x &&
         a.y < b.y + b.h &&
         a.y + a.h > b.y;
}

/* ---------- Game Loop ---------- */
const SCROLL_SPEED = 4; // slightly slower to ease difficulty

function startGame() {
  initObstacles();
  animate();
}

function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawGround();

  // Move/draw obstacles
  obstacles.forEach(ob => ob.update(SCROLL_SPEED));

  // Update/draw player
  player.update();

  // Collision detection + hit handling
  const pRect = player.rect;
  for (const ob of obstacles) {
    const colliding = rectsOverlap(pRect, ob.rect);
    if (colliding && !ob.wasColliding) {
      // New collision event with this obstacle
      hitCount++;
      hitCountEl.textContent = String(hitCount);
      beep(); // play sound
    }
    ob.wasColliding = colliding;
  }

  requestAnimationFrame(animate);
}

/* ---------- Input (Keyboard + Tap/Click) & Resize ---------- */
function handleJumpInput() {
  oneTimeAudioUnlock();
  player && player.jump();
}

window.addEventListener('keydown', e => {
  keys[e.key] = true;
  if (e.key === ' ' || e.key === 'ArrowUp') {
    handleJumpInput();
  }
});
window.addEventListener('keyup', e => { keys[e.key] = false; });

// Cover both mouse and touch; iOS prefers a user gesture before audio
window.addEventListener('pointerdown', handleJumpInput, { passive: true });
window.addEventListener('touchstart', handleJumpInput, { passive: true });

window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  if (player) {
    player.y = canvas.height - groundHeight - player.height;
  }
  // Re-seat obstacles on new ground height
  obstacles.forEach(ob => {
    ob.y = canvas.height - groundHeight - ob.height;
  });
});
</script>
</body>
</html>
