<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Simple Roblox-Inspired Game</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #87ceeb; /* sky blue */
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    canvas {
      display: block;
      background: linear-gradient(#87ceeb 70%, #4caf50 30%);
    }
    /* Top-right shame counter */
    #shameCounter {
      position: fixed;
      top: 12px;
      right: 12px;
      z-index: 10;
      background: rgba(0,0,0,0.6);
      color: #fff;
      padding: 8px 12px;
      border-radius: 8px;
      font-weight: 700;
      letter-spacing: 0.3px;
      user-select: none;
    }
    /* Upper-left pause button */
    #pauseBtn {
      position: fixed;
      top: 12px;
      left: 12px;
      z-index: 11;
      background: rgba(0,0,0,0.65);
      color: #fff;
      border: none;
      padding: 8px 12px;
      border-radius: 8px;
      font-weight: 700;
      letter-spacing: 0.3px;
      cursor: pointer;
      user-select: none;
      transition: transform 0.08s ease;
    }
    #pauseBtn:active { transform: scale(0.98); }
    /* Paused overlay text */
    #pausedOverlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9;
      color: #ffffff;
      font-weight: 800;
      text-shadow: 0 2px 8px rgba(0,0,0,0.6);
      pointer-events: none;
    }
    #pausedOverlay.visible { display: flex; }
    #pausedOverlay span {
      background: rgba(0,0,0,0.35);
      padding: 12px 18px;
      border-radius: 12px;
      font-size: clamp(20px, 4vw, 42px);
      letter-spacing: 0.6px;
    }
  </style>
</head>
<body>
  <button id="pauseBtn" aria-pressed="false" aria-label="Pause game">Pause</button>
  <div id="shameCounter">Shame Hits: <span id="hitCount">0</span></div>
  <div id="pausedOverlay"><span>Paused</span></div>
  <canvas id="game"></canvas>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const groundHeight = 80;
let keys = {};
let obstacles = [];
let collectibles = []; // beach balls
let hitCount = 0;
let obstacleSpawnCount = 0; // count of total spawns (initial + respawns)
let isPaused = false;

const hitCountEl = document.getElementById('hitCount');
const pauseBtn = document.getElementById('pauseBtn');
const pausedOverlay = document.getElementById('pausedOverlay');

/* ---------- Simple beeps via Web Audio ---------- */
let audioCtx = null;
function ensureAudioContext() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
}
function beep(durationMs = 120, freq = 660) {
  if (!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();

  osc.type = 'square';
  osc.frequency.value = freq;

  const now = audioCtx.currentTime;
  gain.gain.setValueAtTime(0.001, now);
  gain.gain.exponentialRampToValueAtTime(0.2, now + 0.01);
  gain.gain.exponentialRampToValueAtTime(0.001, now + durationMs / 1000);

  osc.connect(gain).connect(audioCtx.destination);
  osc.start(now);
  osc.stop(now + durationMs / 1000 + 0.02);
}

/* A friendlier two-tone chime for beach ball hits */
function goodChime() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;

  const tone = (f, start, dur) => {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'triangle';
    osc.frequency.value = f;
    gain.gain.setValueAtTime(0.0001, start);
    gain.gain.exponentialRampToValueAtTime(0.25, start + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.0001, start + dur);
    osc.connect(gain).connect(audioCtx.destination);
    osc.start(start);
    osc.stop(start + dur + 0.02);
  };

  tone(880,  now,      0.10);
  tone(1320, now + .1, 0.12);
}

/* ---------- Entities ---------- */
class Player {
  constructor(img) {
    this.img = img;
    this.width = 120;
    this.height = 160;
    this.x = 100;
    this.y = canvas.height - groundHeight - this.height;
    this.vy = 0;
    this.jumpPower = -16;
    this.gravity = 0.7;
    this.grounded = true;
  }
  draw() {
    ctx.drawImage(this.img, this.x, this.y, this.width, this.height);
  }
  jump() {
    if (this.grounded) {
      this.vy = this.jumpPower;
      this.grounded = false;
    }
  }
  update() {
    if (keys['ArrowUp'] || keys[' ']) this.jump();
    this.vy += this.gravity;
    this.y += this.vy;
    if (this.y >= canvas.height - groundHeight - this.height) {
      this.y = canvas.height - groundHeight - this.height;
      this.vy = 0;
      this.grounded = true;
    }
    this.draw();
  }
  get rect() {
    return { x: this.x, y: this.y, w: this.width, h: this.height };
  }
}

class Obstacle {
  constructor(x, width, height) {
    this.x = x;
    this.width = width;
    this.height = height;
    this.y = canvas.height - groundHeight - this.height;
    this.color = '#d32f2f';
    this.wasColliding = false;
  }
  drawNoteIcon() {
    const pad = Math.min(this.width, this.height) * 0.15;
    const w = this.width - pad * 2;
    const h = this.height - pad * 2;
    const x = this.x + pad;
    const y = this.y + pad;

    ctx.fillStyle = '#fff';
    ctx.fillRect(x, y, w, h);

    const foldSize = Math.min(w, h) * 0.22;
    ctx.fillStyle = '#e0e0e0';
    ctx.beginPath();
    ctx.moveTo(x + w, y);
    ctx.lineTo(x + w - foldSize, y);
    ctx.lineTo(x + w, y + foldSize);
    ctx.closePath();
    ctx.fill();

    ctx.strokeStyle = '#9e9e9e';
    ctx.lineWidth = Math.max(1, Math.floor(h * 0.03));
    const lines = 3;
    for (let i = 1; i <= lines; i++) {
      const ly = y + (h * (i / (lines + 1)));
      ctx.beginPath();
      ctx.moveTo(x + h * 0.12, ly);
      ctx.lineTo(x + w - h * 0.12, ly);
      ctx.stroke();
    }
  }
  draw() {
    ctx.fillStyle = this.color;
    ctx.fillRect(this.x, this.y, this.width, this.height);
    this.drawNoteIcon();
  }
  update(speed) {
    this.x -= speed;
    if (this.x + this.width < 0) {
      // respawn farther ahead with generous spacing/size range
      this.x = canvas.width + 500 + Math.random() * 700;
      this.width = 35 + Math.random() * 25;
      this.height = 24 + Math.random() * 36;
      this.y = canvas.height - groundHeight - this.height;
      this.wasColliding = false;
      onObstacleSpawn(this.x);
    }
    this.draw();
  }
  get rect() {
    return { x: this.x, y: this.y, w: this.width, h: this.height };
  }
}

/* Beach Ball (collectible) */
class BeachBall {
  constructor(x, y, r = 22) {
    this.x = x;
    this.y = y;
    this.r = r;
    this.wasColliding = false;
    this.collected = false;
  }
  draw() {
    const cx = this.x, cy = this.y, r = this.r;

    // base circle (white)
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#222';
    ctx.stroke();

    // colored pie slices (simple beach ball look)
    const colors = ['#ff5252', '#ffd54f', '#4fc3f7', '#81c784'];
    for (let i = 0; i < 4; i++) {
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.fillStyle = colors[i];
      ctx.arc(cx, cy, r, (i * Math.PI / 2), ((i + 1) * Math.PI / 2));
      ctx.closePath();
      ctx.fill();
    }

    // small hub circle
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(cx, cy, r * 0.25, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#222';
    ctx.stroke();
  }
  update(speed) {
    this.x -= speed;
    this.draw();
  }
  get rect() {
    return { x: this.x - this.r, y: this.y - this.r, w: this.r * 2, h: this.r * 2 };
  }
}

/* ---------- Sprite ---------- */
const playerImg = new Image();
playerImg.src = './seth.png.png'; // your sprite image

let player;
playerImg.onload = () => {
  player = new Player(playerImg);
  startGame();
};

/* ---------- Spawning Helpers ---------- */
function onObstacleSpawn(xRight) {
  obstacleSpawnCount++;
  // For every 10 obstacles spawned, 50% chance to spawn ONE beach ball
  if (obstacleSpawnCount % 10 === 0 && Math.random() < 0.5) {
    spawnBeachBall(xRight);
  }
}

function spawnBeachBall(xRight) {
  // place the ball somewhere ahead of the obstacle spawn point
  const x = Math.max(canvas.width + 200, xRight + 150 + Math.random() * 300);
  // random height above the ground, but not too high
  const minAboveGround = 30;
  const maxAboveGround = Math.min(180, canvas.height - groundHeight - 60);
  const y = canvas.height - groundHeight - (minAboveGround + Math.random() * maxAboveGround);
  const r = 20 + Math.random() * 6;
  collectibles.push(new BeachBall(x, y, r));
}

/* ---------- Obstacles ---------- */
function initObstacles() {
  obstacles.length = 0;
  collectibles.length = 0;
  obstacleSpawnCount = 0;

  const count = 4;
  for (let i = 0; i < count; i++) {
    let width = 35 + Math.random() * 25;
    let height = 24 + Math.random() * 36;
    const gap = 520 + Math.random() * 320;
    const ob = new Obstacle(canvas.width + i * gap, width, height);
    obstacles.push(ob);
    onObstacleSpawn(ob.x); // initial spawns count, can trigger ball
  }
}

/* ---------- Utility ---------- */
function drawGround() {
  ctx.fillStyle = "#4caf50";
  ctx.fillRect(0, canvas.height - groundHeight, canvas.width, groundHeight);
  ctx.fillStyle = "#333";
  ctx.fillRect(0, canvas.height - groundHeight, canvas.width, 5);
}

function drawPausedOverlay() {
  // extra visual hint on canvas (optional)
  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.25)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}

function rectsOverlap(a, b) {
  return a.x < b.x + b.w &&
         a.x + a.w > b.x &&
         a.y < b.y + b.h &&
         a.y + a.h > b.y;
}

function circleRectOverlap(circle, rect) {
  // clamp circle center to rect, then check distance
  const cx = circle.x, cy = circle.y, r = circle.r;
  const nearestX = Math.max(rect.x, Math.min(cx, rect.x + rect.w));
  const nearestY = Math.max(rect.y, Math.min(cy, rect.y + rect.h));
  const dx = cx - nearestX;
  const dy = cy - nearestY;
  return (dx*dx + dy*dy) <= r*r;
}

/* ---------- Game Loop ---------- */
const SCROLL_SPEED = 8;

function startGame() {
  initObstacles();
  loop();
}

function updateAndRender() {
  // Move/draw obstacles
  obstacles.forEach(ob => ob.update(SCROLL_SPEED));

  // Move/draw collectibles, remove offscreen or collected
  collectibles.forEach(ball => ball.update(SCROLL_SPEED));
  collectibles = collectibles.filter(b => !b.collected && (b.x + b.r) > 0);

  // Update/draw player
  player.update();

  // Collisions: obstacles (bad)
  const pRect = player.rect;
  for (const ob of obstacles) {
    const colliding = rectsOverlap(pRect, ob.rect);
    if (colliding && !ob.wasColliding) {
      hitCount++;
      hitCountEl.textContent = String(hitCount);
      beep(); // bad hit
    }
    ob.wasColliding = colliding;
  }

  // Collisions: beach balls (good)
  for (const ball of collectibles) {
    const colliding = circleRectOverlap(ball, pRect);
    if (colliding && !ball.wasColliding) {
      hitCount = Math.max(0, hitCount - 1); // decrease shame
      hitCountEl.textContent = String(hitCount);
      goodChime();
      ball.collected = true; // remove it
    }
    ball.wasColliding = colliding;
  }
}

function renderStaticFrame() {
  // Draw only the current (non-advanced) frame + overlay
  obstacles.forEach(ob => ob.draw());
  collectibles.forEach(ball => ball.draw());
  player.draw();
  drawPausedOverlay();
}

function loop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawGround();

  if (!isPaused) {
    updateAndRender();
  } else {
    renderStaticFrame();
  }

  requestAnimationFrame(loop);
}

/* ---------- Pause/Resume ---------- */
function setPaused(next) {
  isPaused = next;
  pauseBtn.textContent = isPaused ? 'Resume' : 'Pause';
  pauseBtn.setAttribute('aria-pressed', String(isPaused));
  pausedOverlay.classList.toggle('visible', isPaused);
}

pauseBtn.addEventListener('click', (e) => {
  e.preventDefault();
  setPaused(!isPaused);
});

window.addEventListener('keydown', (e) => {
  // Toggle pause with P or Escape
  if (e.key === 'p' || e.key === 'P' || e.key === 'Escape') {
    setPaused(!isPaused);
    return;
  }
});

/* ---------- Input & Resize ---------- */
function primeAudio() {
  if (!audioCtx) {
    ensureAudioContext();
    if (audioCtx.state === 'suspended') audioCtx.resume();
  }
}

function handleJumpInput() {
  if (isPaused) return; // ignore jump while paused
  primeAudio();
  player && player.jump();
}

window.addEventListener('keydown', e => {
  keys[e.key] = true;
  if (!isPaused && (e.key === ' ' || e.key === 'ArrowUp')) handleJumpInput();
});
window.addEventListener('keyup', e => { keys[e.key] = false; });

window.addEventListener('pointerdown', () => {
  if (!isPaused) handleJumpInput();
}, { passive: true });

window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  if (player) {
    player.y = canvas.height - groundHeight - player.height;
  }
  obstacles.forEach(ob => {
    ob.y = canvas.height - groundHeight - ob.height;
  });
});
</script>
</body>
</html>
