<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Simple Roblox-Inspired Game</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #87ceeb; /* sky blue */
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    canvas {
      display: block;
      background: linear-gradient(#87ceeb 70%, #4caf50 30%);
    }
    #shameCounter {
      position: fixed;
      top: 12px;
      right: 12px;
      z-index: 10;
      background: rgba(0,0,0,0.6);
      color: #fff;
      padding: 8px 12px;
      border-radius: 8px;
      font-weight: 700;
      letter-spacing: 0.3px;
      user-select: none;
    }
    #pauseBtn {
      position: fixed;
      top: 12px;
      left: 12px;
      z-index: 11;
      background: rgba(0,0,0,0.65);
      color: #fff;
      border: none;
      padding: 8px 12px;
      border-radius: 8px;
      font-weight: 700;
      letter-spacing: 0.3px;
      cursor: pointer;
      user-select: none;
      transition: transform 0.08s ease;
    }
    #pauseBtn:active { transform: scale(0.98); }
    #pausedOverlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9;
      color: #ffffff;
      font-weight: 800;
      text-shadow: 0 2px 8px rgba(0,0,0,0.6);
      pointer-events: none;
    }
    #pausedOverlay.visible { display: flex; }
    #pausedOverlay span {
      background: rgba(0,0,0,0.35);
      padding: 12px 18px;
      border-radius: 12px;
      font-size: clamp(20px, 4vw, 42px);
      letter-spacing: 0.6px;
    }
  </style>
</head>
<body>
  <button id="pauseBtn" aria-pressed="false" aria-label="Pause game">Pause</button>
  <div id="shameCounter">Shame Hits: <span id="hitCount">0</span></div>
  <div id="pausedOverlay"><span>Paused</span></div>
  <canvas id="game"></canvas>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const groundHeight = 80;
let keys = {};
let obstacles = [];
let collectibles = [];
let hitCount = 0;
let obstacleSpawnCount = 0;
let isPaused = false;

const hitCountEl = document.getElementById('hitCount');
const pauseBtn = document.getElementById('pauseBtn');
const pausedOverlay = document.getElementById('pausedOverlay');

/* ---------- Audio ---------- */
let audioCtx = null;
function ensureAudioContext() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}
function beep(durationMs = 120, freq = 660) {
  if (!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = 'square';
  osc.frequency.value = freq;
  const now = audioCtx.currentTime;
  gain.gain.setValueAtTime(0.001, now);
  gain.gain.exponentialRampToValueAtTime(0.2, now + 0.01);
  gain.gain.exponentialRampToValueAtTime(0.001, now + durationMs/1000);
  osc.connect(gain).connect(audioCtx.destination);
  osc.start(now);
  osc.stop(now + durationMs/1000 + 0.02);
}
function goodChime() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  const tone = (f, start, dur) => {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'triangle';
    osc.frequency.value = f;
    gain.gain.setValueAtTime(0.0001, start);
    gain.gain.exponentialRampToValueAtTime(0.25, start + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.0001, start + dur);
    osc.connect(gain).connect(audioCtx.destination);
    osc.start(start);
    osc.stop(start + dur + 0.02);
  };
  tone(880, now, 0.1);
  tone(1320, now + .1, 0.12);
}

/* ---------- Player with Sprite ---------- */
class Player {
  constructor(img) {
    this.img = img;
    this.sheetCols = 6;
    this.sheetRows = 3;
    this.frameW = img.width / this.sheetCols;
    this.frameH = img.height / this.sheetRows;

    this.width = 120;
    this.height = 160;
    this.x = 100;
    this.y = canvas.height - groundHeight - this.height;

    this.vy = 0;
    this.jumpPower = -16;
    this.gravity = 0.7;
    this.grounded = true;

    this.frameIndex = 0;
    this.frameTimer = 0;
    this.frameInterval = 120; // ms per frame
    this.state = "run"; // run, bad, good
  }
  setState(s) {
    this.state = s;
    this.frameIndex = 0;
    this.frameTimer = 0;
  }
  update() {
    if (keys['ArrowUp'] || keys[' ']) this.jump();
    this.vy += this.gravity;
    this.y += this.vy;
    if (this.y >= canvas.height - groundHeight - this.height) {
      this.y = canvas.height - groundHeight - this.height;
      this.vy = 0;
      this.grounded = true;
    }
    this.animate();
  }
  jump() {
    if (this.grounded) {
      this.vy = this.jumpPower;
      this.grounded = false;
    }
  }
  animate() {
    const now = performance.now();
    if (!this.lastTime) this.lastTime = now;
    const delta = now - this.lastTime;
    this.lastTime = now;

    this.frameTimer += delta;
    if (this.frameTimer > this.frameInterval) {
      this.frameIndex = (this.frameIndex + 1) % this.sheetCols;
      this.frameTimer = 0;
    }

    let row = 0;
    if (this.state === "run") row = 0;
    else if (this.state === "bad") row = 1;
    else if (this.state === "good") row = 2;

    ctx.drawImage(
      this.img,
      this.frameW * this.frameIndex, row * this.frameH,
      this.frameW, this.frameH,
      this.x, this.y,
      this.width, this.height
    );
  }
  get rect() {
    return { x: this.x, y: this.y, w: this.width, h: this.height };
  }
}

/* ---------- Obstacle ---------- */
class Obstacle {
  constructor(x, w, h) {
    this.x = x;
    this.width = w;
    this.height = h;
    this.y = canvas.height - groundHeight - this.height;
    this.wasColliding = false;
  }
  draw() {
    ctx.fillStyle = "#d32f2f";
    ctx.fillRect(this.x, this.y, this.width, this.height);
  }
  update(speed) {
    this.x -= speed;
    if (this.x + this.width < 0) {
      this.x = canvas.width + 500 + Math.random()*700;
      this.width = 35 + Math.random()*25;
      this.height = 24 + Math.random()*36;
      this.y = canvas.height - groundHeight - this.height;
      this.wasColliding = false;
      onObstacleSpawn(this.x);
    }
    this.draw();
  }
  get rect() { return {x:this.x,y:this.y,w:this.width,h:this.height}; }
}

/* ---------- BeachBall ---------- */
class BeachBall {
  constructor(x,y,r=22) {
    this.x=x; this.y=y; this.r=r;
    this.wasColliding=false; this.collected=false;
  }
  draw() {
    ctx.fillStyle="#fff";
    ctx.beginPath();
    ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle="#222"; ctx.lineWidth=2; ctx.stroke();
    const colors=['#ff5252','#ffd54f','#4fc3f7','#81c784'];
    for(let i=0;i<4;i++){
      ctx.beginPath();
      ctx.moveTo(this.x,this.y);
      ctx.fillStyle=colors[i];
      ctx.arc(this.x,this.y,this.r,i*Math.PI/2,(i+1)*Math.PI/2);
      ctx.closePath(); ctx.fill();
    }
  }
  update(speed){this.x-=speed;this.draw();}
  get rect(){return {x:this.x-this.r,y:this.y-this.r,w:this.r*2,h:this.r*2};}
}

/* ---------- Load Sprite ---------- */
const playerImg = new Image();
playerImg.src = './seth-move.png';
let player;
playerImg.onload = () => {
  player = new Player(playerImg);
  startGame();
};

/* ---------- Spawn Helpers ---------- */
function onObstacleSpawn(xRight){
  obstacleSpawnCount++;
  if(obstacleSpawnCount%10===0 && Math.random()<0.5) spawnBeachBall(xRight);
}
function spawnBeachBall(xRight){
  const x = Math.max(canvas.width+200,xRight+150+Math.random()*300);
  const y = canvas.height-groundHeight-(30+Math.random()*120);
  const r = 20+Math.random()*6;
  collectibles.push(new BeachBall(x,y,r));
}

/* ---------- Init Obstacles ---------- */
function initObstacles(){
  obstacles=[]; collectibles=[]; obstacleSpawnCount=0;
  for(let i=0;i<4;i++){
    let w=35+Math.random()*25,h=24+Math.random()*36;
    const gap=520+Math.random()*320;
    const ob=new Obstacle(canvas.width+i*gap,w,h);
    obstacles.push(ob); onObstacleSpawn(ob.x);
  }
}

/* ---------- Utils ---------- */
function drawGround(){
  ctx.fillStyle="#4caf50";
  ctx.fillRect(0,canvas.height-groundHeight,canvas.width,groundHeight);
  ctx.fillStyle="#333";
  ctx.fillRect(0,canvas.height-groundHeight,canvas.width,5);
}
function rectsOverlap(a,b){return a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y;}
function circleRectOverlap(c,r){
  const nearestX=Math.max(r.x,Math.min(c.x,r.x+r.w));
  const nearestY=Math.max(r.y,Math.min(c.y,r.y+r.h));
  const dx=c.x-nearestX,dy=c.y-nearestY;
  return dx*dx+dy*dy <= c.r*c.r;
}

/* ---------- Game Loop ---------- */
const SCROLL_SPEED=8;
function startGame(){initObstacles();loop();}
function updateAndRender(){
  obstacles.forEach(o=>o.update(SCROLL_SPEED));
  collectibles.forEach(b=>b.update(SCROLL_SPEED));
  collectibles=collectibles.filter(b=>!b.collected && b.x+b.r>0);

  player.update();

  const p=player.rect;
  for(const ob of obstacles){
    const colliding=rectsOverlap(p,ob.rect);
    if(colliding && !ob.wasColliding){
      hitCount++; hitCountEl.textContent=hitCount;
      beep(); player.setState("bad");
      setTimeout(()=>player.setState("run"),400);
    }
    ob.wasColliding=colliding;
  }
  for(const b of collectibles){
    const colliding=circleRectOverlap(b,p);
    if(colliding && !b.wasColliding){
      hitCount=Math.max(0,hitCount-1);
      hitCountEl.textContent=hitCount;
      goodChime(); b.collected=true;
      player.setState("good");
      setTimeout(()=>player.setState("run"),400);
    }
    b.wasColliding=colliding;
  }
}
function loop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawGround();
  if(!isPaused) updateAndRender();
  requestAnimationFrame(loop);
}

/* ---------- Pause ---------- */
function setPaused(next){
  isPaused=next;
  pauseBtn.textContent=isPaused?"Resume":"Pause";
  pauseBtn.setAttribute("aria-pressed",String(isPaused));
  pausedOverlay.classList.toggle("visible",isPaused);
}
pauseBtn.addEventListener("click",e=>{e.preventDefault();setPaused(!isPaused);});
window.addEventListener("keydown",e=>{
  if(e.key==="p"||e.key==="P"||e.key==="Escape"){setPaused(!isPaused);return;}
});

/* ---------- Input ---------- */
function primeAudio(){if(!audioCtx){ensureAudioContext();if(audioCtx.state==="suspended") audioCtx.resume();}}
function handleJumpInput(){if(isPaused)return;primeAudio();player&&player.jump();}
window.addEventListener("keydown",e=>{keys[e.key]=true;if((e.key===" "||e.key==="ArrowUp")&&!isPaused)handleJumpInput();});
window.addEventListener("keyup",e=>{keys[e.key]=false;});
window.addEventListener("pointerdown",()=>{if(!isPaused)handleJumpInput();},{passive:true});

/* ---------- Resize ---------- */
window.addEventListener("resize",()=>{
  canvas.width=window.innerWidth; canvas.height=window.innerHeight;
  if(player) player.y=canvas.height-groundHeight-player.height;
  obstacles.forEach(o=>{o.y=canvas.height-groundHeight-o.height;});
});
</script>
</body>
</html>
