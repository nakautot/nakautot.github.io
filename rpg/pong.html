<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>PingPong (DOS-like with Power-Ups)</title>
<style>
  :root { --fg: #00ff00; --bg: #000; }
  html,body { height:100%; margin:0; background:var(--bg); color:var(--fg);
              font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  #wrap { display:grid; place-items:center; height:100%; }
  canvas { background: #000; image-rendering: pixelated; border: 2px solid var(--fg); }
  .hud { position: fixed; top: 10px; left: 50%; transform: translateX(-50%);
         display:flex; gap:40px; align-items:center; font-weight:700; font-size:18px; }
  .msg  { position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%);
          color: var(--fg); opacity: .85; font-size: 14px; text-align:center; }
  .btn  { padding: 2px 8px; border: 1px solid var(--fg); cursor: pointer; user-select:none; }
  .btn:active { transform: translateY(1px); }
</style>
</head>
<body>
<div id="wrap">
  <div class="hud">
    <div>üÖõ <span id="lScore">0</span></div>
    <div>üÖ° <span id="rScore">0</span></div>
    <div class="btn" id="reset">Reset</div>
  </div>
  <canvas id="game" width="800" height="500" aria-label="Pong"></canvas>
  <div class="msg" id="msg">
    Controls: Left=W/S ‚Ä¢ Right=‚Üë/‚Üì ‚Ä¢ Space=Serve ‚Ä¢ P=Pause
  </div>
</div>

<script>
(() => {
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d');
  const lEl = document.getElementById('lScore');
  const rEl = document.getElementById('rScore');
  const msg = document.getElementById('msg');
  const resetBtn = document.getElementById('reset');
  const W = cvs.width, H = cvs.height;

  // --- Audio helper ---
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  function beep(freq = 440, dur = 0.1) {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = "square";
    osc.frequency.value = freq;
    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
    osc.connect(gain).connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + dur);
  }

  // Game state
  let running = true;
  let waitingServe = true;
  let winner = null;
  const MAX_SCORE = 10;

  // Paddles
  const P_WIDTH = 10, P_HEIGHT = 80, P_SPEED = 6;
  const BASE_P_HEIGHT = P_HEIGHT;
  const left = { x: 20, y: (H - P_HEIGHT) / 2, vy: 0, score: 0, up:'KeyW', down:'KeyS', h:P_HEIGHT };
  const right= { x: W - 20 - P_WIDTH, y: (H - P_HEIGHT) / 2, vy: 0, score: 0, up:'ArrowUp', down:'ArrowDown', h:P_HEIGHT };

  // Ball
  const BALL = { x: W/2, y: H/2, r: 7, vx: 0, vy: 0, speed: 6, maxSpeed: 10 };

  // Power-ups: array of {x,y,size,type}
  let powerUps = [];
  let powerActive = false;
  let effectTimeoutId = null;

  function spawnPowerUp() {
    const type = Math.random() < 0.5 ? "expand" : "shrink";
    powerUps.push({
      x: Math.random() * (W-40) + 20,
      y: Math.random() * (H-40) + 20,
      size: 15,
      type
    });
  }

  function serve(toRight = Math.random() < 0.5) {
    BALL.x = W/2; BALL.y = H/2;
    const angle = (Math.random() * 60 - 30) * Math.PI/180;
    const dir = toRight ? 1 : -1;
    BALL.vx = dir * BALL.speed * Math.cos(angle);
    BALL.vy = BALL.speed * Math.sin(angle);
    waitingServe = false;
    msg.textContent = 'P to Pause';
    beep(800,0.15);
    spawnPowerUp(); // always spawn new power-up
  }

  function drawRect(x, y, w, h) { ctx.fillRect(x, y, w, h); }
  function drawCircle(x, y, r) { ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill(); }

  // Input
  const keys = new Set();
  window.addEventListener('keydown', (e) => {
    keys.add(e.code);
    if (e.code === 'Space' && waitingServe && !winner) serve(Math.random()<0.5);
    if (e.code === 'KeyP') { running = !running; if (running) loop(); }
  });
  window.addEventListener('keyup', (e) => keys.delete(e.code));

  resetBtn.addEventListener('click', () => hardReset());

  function clearEffect() {
    if (effectTimeoutId) {
      clearTimeout(effectTimeoutId);
      effectTimeoutId = null;
    }
    left.h = BASE_P_HEIGHT;
    right.h = BASE_P_HEIGHT;
    left.y = Math.min(left.y, H - left.h);
    right.y = Math.min(right.y, H - right.h);
    powerActive = false;
  }

  function hardReset() {
    left.score = right.score = 0;
    lEl.textContent = rEl.textContent = '0';
    winner = null;
    msg.textContent = 'Press Space to Serve';
    waitingServe = true;
    running = true;
    clearEffect();
    left.y = right.y = (H - BASE_P_HEIGHT)/2;
    BALL.vx = BALL.vy = 0; BALL.x = W/2; BALL.y = H/2;
    powerUps = [];
    loop();
  }

  function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

  function update() {
    left.vy = (keys.has(left.up) ? -P_SPEED : 0) + (keys.has(left.down) ? P_SPEED : 0);
    right.vy= (keys.has(right.up)? -P_SPEED : 0) + (keys.has(right.down)? P_SPEED : 0);

    left.y = clamp(left.y + left.vy, 0, H - left.h);
    right.y= clamp(right.y + right.vy, 0, H - right.h);

    if (!waitingServe && !winner) {
      BALL.x += BALL.vx;
      BALL.y += BALL.vy;

      // Wall collisions
      if (BALL.y - BALL.r <= 0 && BALL.vy < 0) { BALL.y = BALL.r; BALL.vy *= -1; beep(400,0.08); }
      if (BALL.y + BALL.r >= H && BALL.vy > 0) { BALL.y = H - BALL.r; BALL.vy *= -1; beep(400,0.08); }

      // Paddle collisions
      const collidePaddle = (p) => {
        if (BALL.y + BALL.r < p.y || BALL.y - BALL.r > p.y + p.h) return false;
        if (p === left && BALL.x - BALL.r <= p.x + P_WIDTH && BALL.vx < 0 && BALL.x > p.x) {
          BALL.x = p.x + P_WIDTH + BALL.r;
        } else if (p === right && BALL.x + BALL.r >= p.x && BALL.vx > 0 && BALL.x < p.x + P_WIDTH) {
          BALL.x = p.x - BALL.r;
        } else return false;

        const hitPos = ((BALL.y - (p.y + p.h/2)) / (p.h/2));
        const angle = hitPos * (Math.PI/3);
        const dir = p === left ? 1 : -1;
        const speed = Math.min(Math.hypot(BALL.vx, BALL.vy) * 1.05, BALL.maxSpeed);

        BALL.vx = dir * speed * Math.cos(angle);
        BALL.vy = speed * Math.sin(angle);
        beep(600,0.1);
        return true;
      };

      collidePaddle(left);
      collidePaddle(right);

      // Power-up collisions (apply only if no active effect)
      if (!powerActive && powerUps.length) {
        powerUps = powerUps.filter(pu => {
          if (Math.abs(BALL.x - pu.x) < pu.size && Math.abs(BALL.y - pu.y) < pu.size) {
            powerActive = true;
            // apply effect
            if (pu.type === "expand") {
              left.h = Math.round(BASE_P_HEIGHT * 1.5);
              right.h = Math.round(BASE_P_HEIGHT * 1.5);
              beep(1000,0.2);
            } else {
              left.h = Math.round(BASE_P_HEIGHT * 0.5);
              right.h = Math.round(BASE_P_HEIGHT * 0.5);
              beep(300,0.2);
            }
            // keep paddles inside bounds after resize
            left.y = Math.min(left.y, H - left.h);
            right.y = Math.min(right.y, H - right.h);

            // schedule effect end in 2 seconds
            effectTimeoutId = setTimeout(() => {
              clearEffect();
            }, 2000);

            return false; // remove collected power-up
          }
          return true; // keep others
        });
      }

      // Scoring
      if (BALL.x < -BALL.r) {
        rEl.textContent = String(++right.score);
        pointEnd();
        beep(200,0.3);
      } else if (BALL.x > W + BALL.r) {
        lEl.textContent = String(++left.score);
        pointEnd();
        beep(200,0.3);
      }
    }
  }

  function pointEnd() {
    waitingServe = true;
    BALL.vx = BALL.vy = 0;
    BALL.x = W/2; BALL.y = H/2;
    msg.textContent = 'Point! Press Space to Serve';
    // effects are time-based; no forced reset here (timer will revert if still active)
    if (left.score >= MAX_SCORE || right.score >= MAX_SCORE) {
      winner = left.score > right.score ? 'Left' : 'Right';
      msg.textContent = `üèÜ ${winner} wins! Click Reset to play again.`;
      running = false;
    }
  }

  function draw() {
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = '#00ff00';
    for (let y = 0; y < H; y += 18) drawRect(W/2 - 2, y, 4, 12);
    drawRect(left.x, left.y, P_WIDTH, left.h);
    drawRect(right.x, right.y, P_WIDTH, right.h);
    drawCircle(BALL.x, BALL.y, BALL.r);

    // Draw all power-ups
    powerUps.forEach(pu => {
      ctx.fillStyle = pu.type === "expand" ? "#0f0" : "#f00";
      ctx.fillRect(pu.x-7, pu.y-7, pu.size, pu.size);
    });
    ctx.fillStyle = '#00ff00';
  }

  function loop() {
    if (!running) return;
    update(); draw();
    requestAnimationFrame(loop);
  }

  msg.textContent = 'Press Space to Serve ‚Ä¢ P to Pause';
  draw();
  loop();
})();
</script>
</body>
</html>
