<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>PingPong (DOS-like)</title>
<style>
  :root { --fg: #00ff00; --bg: #000; }
  html,body { height:100%; margin:0; background:var(--bg); color:var(--fg);
              font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  #wrap { display:grid; place-items:center; height:100%; }
  canvas { background: #000; image-rendering: pixelated; border: 2px solid var(--fg); }
  .hud { position: fixed; top: 10px; left: 50%; transform: translateX(-50%);
         display:flex; gap:40px; align-items:center; font-weight:700; font-size:18px; }
  .msg  { position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%);
          color: var(--fg); opacity: .85; font-size: 14px; text-align:center; }
  .btn  { padding: 2px 8px; border: 1px solid var(--fg); cursor: pointer; user-select:none; }
  .btn:active { transform: translateY(1px); }
</style>
</head>
<body>
<div id="wrap">
  <div class="hud">
    <div>üÖõ <span id="lScore">0</span></div>
    <div>üÖ° <span id="rScore">0</span></div>
    <div class="btn" id="reset">Reset</div>
  </div>
  <canvas id="game" width="800" height="500" aria-label="Pong"></canvas>
  <div class="msg" id="msg">
    Controls: Left=W/S ‚Ä¢ Right=‚Üë/‚Üì ‚Ä¢ Space=Serve ‚Ä¢ P=Pause
  </div>
</div>

<script>
(() => {
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d');
  const lEl = document.getElementById('lScore');
  const rEl = document.getElementById('rScore');
  const msg = document.getElementById('msg');
  const resetBtn = document.getElementById('reset');
  const W = cvs.width, H = cvs.height;

  // --- Audio helper ---
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  function beep(freq = 440, dur = 0.1) {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = "square";
    osc.frequency.value = freq;
    gain.gain.setValueAtTime(0.1, audioCtx.currentTime); // low volume
    osc.connect(gain).connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + dur);
  }

  // Game state
  let running = true;
  let waitingServe = true;
  let winner = null;
  const MAX_SCORE = 10;

  // Paddles
  const P_WIDTH = 10, P_HEIGHT = 80, P_SPEED = 6;
  const left = { x: 20,  y: (H - P_HEIGHT) / 2, vy: 0, score: 0, up:'KeyW', down:'KeyS' };
  const right= { x: W - 20 - P_WIDTH, y: (H - P_HEIGHT) / 2, vy: 0, score: 0, up:'ArrowUp', down:'ArrowDown' };

  // Ball
  const BALL = { x: W/2, y: H/2, r: 7, vx: 0, vy: 0, speed: 6, maxSpeed: 10 };

  function serve(toRight = Math.random() < 0.5) {
    BALL.x = W/2; BALL.y = H/2;
    const angle = (Math.random() * 60 - 30) * Math.PI/180;
    const dir = toRight ? 1 : -1;
    BALL.vx = dir * BALL.speed * Math.cos(angle);
    BALL.vy = BALL.speed * Math.sin(angle);
    waitingServe = false;
    msg.textContent = 'P to Pause';
    beep(800,0.15); // serve beep
  }

  function drawRect(x, y, w, h) { ctx.fillRect(x, y, w, h); }
  function drawCircle(x, y, r) { ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill(); }

  // Input
  const keys = new Set();
  window.addEventListener('keydown', (e) => {
    keys.add(e.code);
    if (e.code === 'Space' && waitingServe && !winner) serve(Math.random()<0.5);
    if (e.code === 'KeyP') { running = !running; if (running) loop(); }
  });
  window.addEventListener('keyup', (e) => keys.delete(e.code));

  resetBtn.addEventListener('click', () => hardReset());

  function hardReset() {
    left.score = right.score = 0;
    lEl.textContent = rEl.textContent = '0';
    winner = null;
    msg.textContent = 'Press Space to Serve';
    waitingServe = true;
    running = true;
    left.y = right.y = (H - P_HEIGHT)/2;
    BALL.vx = BALL.vy = 0; BALL.x = W/2; BALL.y = H/2;
    loop();
  }

  function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

  function update() {
    left.vy = (keys.has(left.up) ? -P_SPEED : 0) + (keys.has(left.down) ? P_SPEED : 0);
    right.vy= (keys.has(right.up)? -P_SPEED : 0) + (keys.has(right.down)? P_SPEED : 0);

    left.y = clamp(left.y + left.vy, 0, H - P_HEIGHT);
    right.y= clamp(right.y + right.vy, 0, H - P_HEIGHT);

    if (!waitingServe && !winner) {
      BALL.x += BALL.vx;
      BALL.y += BALL.vy;

      // Top/bottom walls
      if (BALL.y - BALL.r <= 0 && BALL.vy < 0) { BALL.y = BALL.r; BALL.vy *= -1; beep(400,0.08); }
      if (BALL.y + BALL.r >= H && BALL.vy > 0) { BALL.y = H - BALL.r; BALL.vy *= -1; beep(400,0.08); }

      // Paddle collisions
      const collidePaddle = (p) => {
        if (BALL.y + BALL.r < p.y || BALL.y - BALL.r > p.y + P_HEIGHT) return false;
        if (p === left && BALL.x - BALL.r <= p.x + P_WIDTH && BALL.vx < 0 && BALL.x > p.x) {
          BALL.x = p.x + P_WIDTH + BALL.r;
        } else if (p === right && BALL.x + BALL.r >= p.x && BALL.vx > 0 && BALL.x < p.x + P_WIDTH) {
          BALL.x = p.x - BALL.r;
        } else return false;

        const hitPos = ((BALL.y - (p.y + P_HEIGHT/2)) / (P_HEIGHT/2));
        const angle = hitPos * (Math.PI/3);
        const dir = p === left ? 1 : -1;
        const speed = Math.min(Math.hypot(BALL.vx, BALL.vy) * 1.05, BALL.maxSpeed);

        BALL.vx = dir * speed * Math.cos(angle);
        BALL.vy = speed * Math.sin(angle);
        beep(600,0.1); // paddle hit beep
        return true;
      };

      collidePaddle(left);
      collidePaddle(right);

      // Scoring
      if (BALL.x < -BALL.r) {
        right.score++; rEl.textContent = String(right.score);
        pointEnd(false);
        beep(200,0.3); // miss beep
      } else if (BALL.x > W + BALL.r) {
        left.score++; lEl.textContent = String(left.score);
        pointEnd(true);
        beep(200,0.3); // miss beep
      }
    }
  }

  function pointEnd() {
    waitingServe = true;
    BALL.vx = BALL.vy = 0;
    BALL.x = W/2; BALL.y = H/2;
    msg.textContent = 'Point! Press Space to Serve';
    if (left.score >= MAX_SCORE || right.score >= MAX_SCORE) {
      winner = left.score > right.score ? 'Left' : 'Right';
      msg.textContent = `üèÜ ${winner} wins! Click Reset to play again.`;
      running = false;
    }
  }

  function draw() {
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = '#00ff00';
    for (let y = 0; y < H; y += 18) drawRect(W/2 - 2, y, 4, 12);
    drawRect(left.x, left.y, P_WIDTH, P_HEIGHT);
    drawRect(right.x, right.y, P_WIDTH, P_HEIGHT);
    drawCircle(BALL.x, BALL.y, BALL.r);
  }

  function loop() {
    if (!running) return;
    update(); draw();
    requestAnimationFrame(loop);
  }

  msg.textContent = 'Press Space to Serve ‚Ä¢ P to Pause';
  draw();
  loop();
})();
</script>
</body>
</html>
